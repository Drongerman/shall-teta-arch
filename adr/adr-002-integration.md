# [ADR.002][Опредение шаблона интеграции (метод, структура, взаимодействие)]

* Статус: Предложено
* Владелец: asshalunov@mts.ru

## Контекст
Для системы, состоящей из модулей, ответственных за управления данными (мероприятие, доклады, пользователи, расписание, реклама, бонусы), а также модулей отвественных за интерактив (трансляция, чат, уведомления) необходимо определить шаблон интеграционного взаимодействия (метод, структура, взаимодействие) для построения дальнейшей архитектуры


## Варианты решения

### Метод:
#### Интеграция систем по данным (data-centric)
* **Плюсы**
  * Проще получать связные данные
  * Высокая консистентность связных данных
  * Нет необходимости дублировать данные
  * Более высокое качество данных
  * Проще управлять обновременно разными типами объектов/сущностей в рамках единой транзакции
* **Минусы**
  * Высокая связность данных
  * Необходимость передачи больших объемов данных
  * Риски связанные с безопасностью данных 
#### Объектно-центрический (object-centric)
* **Плюсы**
  * Унифицированный и понятный язык спецификации интерфейсов объектов
  * Понятный жизненный цикл объектов/сущностей
  * Отделение реализации компонентов от спецификации их интерфейсов
  * Более безопасный доступ к данным за счет разделения
* **Минусы**
  * Сложнее управлять обновременно разными типами объектов/сущностей в рамках единой транзакции
  * При разделении контекстов на разные сервисы, необходимо дублировать данные или иметь общую БД
#### Функционально-центрический (function-centric)
* **Плюсы**
  * Проще управлять обновременно разными типами объектов/сущностей в рамках единой транзакции
* **Минусы**
  * Нет прозрачного жизненного цикла объектов/сущностей
  * Зачастую нет четкого разделения контекстов
  * Зачастую несоответствие форматов в рамках разных функций над обним объектом
  * При разделении контекстов на разные сервисы, необходимо дублировать данные или иметь общую БД

### Структура:
#### Точка-точка
* **Плюсы**
  * Нет единого связующего узла, который необходимо отддельно поддерживать
  * Нет единой точки отказа
* **Минусы**
  * Высокая связность сервисов по API
  * При необходимости изменить API в одном сервисе, необходимо менять реализацию во всех клиентах
  * Зачастую необходимо обеспечивать схожую техническую реализацию в разных сервисах
#### Звезда
* **Плюсы**
  * Единое место изменений API
  * Единое место контроля доступа
  * Низкая связность сервисов по API
* **Минусы**
  * Единая точка отказа
  * Необходимо обеспечивать выделенную поддержку центрального сервиса
  * Центральный сервис имеет большое количество зависимостей на API других сервисов
#### Смешанное
* **Плюсы**
  * Сочетает в себе преимущества централизации управления процессами взаимодействия систем, унификации интерфейсов, а также возможность использовать прямые интерфейсы между системами
* **Минусы**
  * Нет единой точки контроля доступа
  * Сложнее обеспечить безопасность
  * Сложнее поддерживать

### Взаимодействие:
#### API Gateway
* **Плюсы**
  * Проще для восприятия (как клиентами, так и разработчиками)
  * Проще обеспечить безопасность
  * Менее ресурсоемкий
* **Минусы**
  * Требует придерживаться определенного формата
  * Не подходит для долгих транзакций
  * Не подходит для реализации сложной логики 
#### ESB
* **Плюсы**
  * Имеет большую функциональность, например валидацию, трансформацию, раутинг, оркестрация
  * Позволяет интегрировать несколько разных систем с разными интерфейсами
* **Минусы**
  * Набор функций зачастую предопределен и требует постоянной доработки
  * Более ресурсоемкий
  * Более сложная реализация
#### GraphQL Federation
* **Плюсы**
  * Клиенто-ориентиованность - формат и состав возращаемых данных зависит от параметров запроса
  * Снимает необходимость несколько раз обращаться за данными
  * Уменьшает зависимость клиента от сервера
* **Минусы**
  * Сложнее для восприятия
  * Сложнее в реализации
  * Сложнее обеспечить безопасность, ограничить доступ
  * Более ресурсоемкий

### Протокол:
  * REST - быстро и просто управлять объектами, популярный
  * gRPC - более гибкий протокол, но мало специалистов на рынке, вероятно необходимо потратить время на обучение
  * GraphQL - сложнее делать бэк, фронт более гибкий, независимый, мало специалистов на рынке, вероятно необходимо потратить время на обучение
  * EDA - сложнее делать бэк, позволит обеспечить BASE, мало специалистов на рынке, вероятно необходимо потратить время на обучение
  * WebSocket - для выполнения онлайн функций в реальном времени

## Решение

### Для модулей, ответственных за управления данными (мероприятие, доклады, пользователи, расписание, реклама, бонусы):

Учитывая необходимость быстрой реализации (ETA конец Q4 2023), необходимость соответсвия Cloud Native архитектуры, отсутсвие необходимости интеграции API с множеством разных клиентов, будет проще реализовать интеграционный подход с простой, легковесной реализацией REST API

Учитывая атомарность операций и отсуствие сложных оркестрационных процессов и интеграционных взаимодействий между подсистемами, для обеспечения доступа к сервисам предлагается использовать API Gateway

Итог: Используем объектно-центрический подход, структуру звезда, взаимодействие API Gateway, протокол REST

### Последствия
- Риск отказа всей функциональности при недоступности API Gateway - риск средний, необходимо обеспечить гео-распреденную инфраструктуру, а также автоматическое масштабирование при достижении определенной нагрузки
- Риск сетевого сбоя при взаимодействии между API Gateway и сервисом (оборвалась связь между API Gateway и сервисом, сервис выполнил запрос, но не смог вернуть ответ) - риск средний, необходимо обеспечить поддержку идемпотентных запросов, в случае повторной отправки из UI/API Gateway


### Для модулей отвественных за интерактив (трансляция, чат):

Данные модули отвественны за выполнение определенных функций в реальном времени, практически без необходимости управления объектами. Данных API мало, изменяться формат будет редко, все системы (веб приложение и бэкенд сервисы) внутренние, при изменении формата API не будет сложностей с синхронизацяей выдачи изменений между бэк и фронт командами

Наиболее высокие нагрузки, необходима максимальная доступность, с минимальными задержками - метод точка-точка наиболее предпочтительный

Итог: Используем функционально-центрический подход, структуру точка-точка, протокол WebSocket

### Последствия
- Риск сбоя функционала Web App при несогласованном изменения формата бэкенд API - рис низкий, сервисы внутренние, команды бэк и фронт синхронизируются
- Необходимость дублирования функционала проверки доступа/безопасности - выделение данного функционала в общую библиотеку


